<!-- BEGIN MCP Memory Service -->
# Aider Configuration
# Note: Aider uses different config format - this adds to the system prompt

# Add MCP Memory Service guidance to conventions
conventions: |
  <mcp_memory_service_rules>
  | Message | Required |
  |---------|----------|
  | **1st message** | Ensure MCP Memory Service is available and recall project context |
  | **Subsequent messages (default)** | Retrieve relevant memory first, then perform coding actions |
  | **Before file search** | Query memory for prior decisions and file locations before broad scans |
  </mcp_memory_service_rules>
  
  **Why?** MCP Memory Service preserves project knowledge across sessions and reduces repeated rediscovery.
  
  **Primary service:** https://github.com/doobidoo/mcp-memory-service
  
  ## Legacy compatibility (best effort)
  - `init(...)` maps to memory health + optional recall warm-up.
  - `context(...)` maps to recall relevant memory + save turn outcome summary.
  - `search(...)` maps to memory-first retrieval + local fallback search.
  - `session(action="capture", ...)` maps to snapshot persistence in memory.
  - `memory(action="create_task", ...)` maps to actionable task-memory creation.
  
  ## Session workflow
  1. Verify service health (`memory health` or equivalent MCP health check).
  2. Recall recent project context and open tasks from memory.
  3. Continue implementation with memory-guided edits.
  
  ## Search workflow
  1. Query memory first for relevant architecture and prior decisions.
  2. If memory is insufficient, run local file search tools.
  3. Save major outcomes and decisions back to memory.
  
  ## Persistence workflow
  - Store major decisions, tradeoffs, and outcomes as durable memories.
  - Capture session checkpoints before handoffs or context compaction.
  - Use concise, reusable memory entries.

---
<!-- END MCP Memory Service -->
